from fastapi import FastAPI, HTTPException
from app.redis_client import redis_client, close_redis
import time
import json
from pydantic import BaseModel

app = FastAPI(title="City Builder Backend", version="0.1.0")

# Konfigurace budov – snadno rozšířitelné (jako v FoE)
BUILDING_CONFIG = {
    "townhall": {
        "max_level": 10,
        "default_x": 10, "default_y": 10,
        "upgrade_cost_gold": [0, 200, 500, 1000, 2000],
        "upgrade_duration": [0, 60, 300, 1800, 3600],
    },
    "farm": {
        "max_level": 10,
        "default_x": 12, "default_y": 12,
        "upgrade_cost_gold": [0, 100, 300, 600, 1200],
        "upgrade_duration": [0, 60, 600, 1800, 3600],
        "production_per_hour_gold": [0, 10, 25, 50, 100]  # gold za hodinu
    },
    "lumbermill": {
        "max_level": 10,
        "upgrade_cost_gold": [0, 150, 400, 800, 1500],
        "upgrade_duration": [0, 60, 600, 1800, 3600],
        "production_per_hour_wood": [0, 15, 30, 60, 120]  # wood za hodinu
    },
    "house": {
        "max_level": 10,
        "upgrade_cost_gold": [0, 80, 200, 500, 1000],
        "upgrade_duration": [0, 60, 300, 1200, 3600],
        # Později může zvyšovat population limit
    },
    "barracks": {
        "max_level": 10,
        "upgrade_cost_gold": [0, 300, 700, 1500, 3000],
        "upgrade_duration": [0, 120, 900, 3600, 7200],
        # Později umožní trénovat jednotky
    }
}

class UpgradeRequest(BaseModel):
    building_id: str  # unikátní ID budovy, např. "farm_0" nebo "lumbermill_1"

class PlaceRequest(BaseModel):
    building_type: str   # typ budovy, např. "farm", "lumbermill"
    x: int
    y: int

@app.on_event("shutdown")
async def shutdown_event():
    await close_redis()

@app.get("/")
async def root():
    return {"message": "City Builder Backend běží!", "timestamp": time.time()}

@app.get("/city/{user_id}")
async def get_city(user_id: str):
    current_time = time.time()
    
    resources_raw = await redis_client.hgetall(f"player:{user_id}")
    buildings_raw = await redis_client.get(f"city:{user_id}:buildings")
    
    # Inicializace nového hráče
    if not resources_raw:
        resources = {"gold": 500.0, "wood": 300.0, "last_collect": current_time}
        await redis_client.hset(f"player:{user_id}", mapping=resources)
    else:
        resources = {k: float(v) if k in ["gold", "wood", "last_collect"] else v 
                     for k, v in resources_raw.items()}
    
    if not buildings_raw:
        buildings = {
            "townhall_0": {"level": 1, "upgrade_start": None, "upgrade_end": None, "x": 10, "y": 10, "type": "townhall"},
            "farm_0": {"level": 1, "upgrade_start": None, "upgrade_end": None, "x": 12, "y": 12, "type": "farm"}
        }
        await redis_client.set(f"city:{user_id}:buildings", json.dumps(buildings))
    else:
        buildings = json.loads(buildings_raw)

    # Lazy dokončení upgradů
    updated = False
    for building_id, data in buildings.items():
        upgrade_end = data.get("upgrade_end")
        if upgrade_end is not None and current_time >= upgrade_end:
            data["level"] += 1
            data["upgrade_start"] = None
            data["upgrade_end"] = None
            updated = True
    
    # Idle production
    gold_production = 0
    wood_production = 0
    for data in buildings.values():
        b_type = data.get("type")
        level = data["level"]
        if b_type == "farm":
            rates = BUILDING_CONFIG["farm"].get("production_per_hour_gold", [0])
            gold_production += rates[min(level - 1, len(rates) - 1)]
        elif b_type == "lumbermill":
            rates = BUILDING_CONFIG["lumbermill"].get("production_per_hour_wood", [0])
            wood_production += rates[min(level - 1, len(rates) - 1)]

    last_collect = resources.get("last_collect", current_time)
    elapsed_hours = (current_time - last_collect) / 3600
    resources["gold"] += elapsed_hours * gold_production
    resources["wood"] += elapsed_hours * wood_production
    
    # Ulož aktualizace
    resources["last_collect"] = current_time
    await redis_client.hset(f"player:{user_id}", "last_collect", current_time)
    await redis_client.hset(f"player:{user_id}", "gold", resources["gold"])
    await redis_client.hset(f"player:{user_id}", "wood", resources["wood"])
    
    if updated:
        await redis_client.set(f"city:{user_id}:buildings", json.dumps(buildings))
    
    return {
        "user_id": user_id,
        "resources": {
            "gold": round(resources["gold"], 2),
            "wood": round(resources["wood"], 2)
        },
        "buildings": buildings,
        "server_time": current_time
    }

@app.post("/city/{user_id}/upgrade")
async def upgrade_building(user_id: str, request: UpgradeRequest):
    building_id = request.building_id

    current_time = time.time()
    buildings_raw = await redis_client.get(f"city:{user_id}:buildings")
    resources_raw = await redis_client.hgetall(f"player:{user_id}")
    
    if not buildings_raw or not resources_raw:
        raise HTTPException(status_code=404, detail="Hráč neexistuje")
    
    buildings = json.loads(buildings_raw)
    if building_id not in buildings:
        raise HTTPException(status_code=404, detail="Budova neexistuje")
    
    resources = {k: float(v) for k, v in resources_raw.items() if k in ["gold", "wood"]}
    building = buildings[building_id]
    b_type = building["type"]
    
    if b_type not in BUILDING_CONFIG:
        raise HTTPException(status_code=400, detail="Neznámý typ budovy")
    
    current_level = building["level"]
    next_level = current_level + 1
    config = BUILDING_CONFIG[b_type]
    
    if next_level > config["max_level"]:
        raise HTTPException(status_code=400, detail="Budova je na max levelu")
    
    if building.get("upgrade_end") is not None:
        raise HTTPException(status_code=400, detail="Upgrade už běží")
    
    cost_gold = config["upgrade_cost_gold"][next_level - 1]
    duration = config["upgrade_duration"][next_level - 1]
    
    if resources["gold"] < cost_gold:
        raise HTTPException(status_code=400, detail="Nedostatek gold")
    
    resources["gold"] -= cost_gold
    building["upgrade_start"] = current_time
    building["upgrade_end"] = current_time + duration
    
    await redis_client.hset(f"player:{user_id}", "gold", resources["gold"])
    await redis_client.set(f"city:{user_id}:buildings", json.dumps(buildings))
    
    return {
        "message": f"Upgrade {b_type} ({building_id}) na level {next_level} spuštěn",
        "cost_gold": cost_gold,
        "duration_seconds": duration,
        "finish_time": building["upgrade_end"]
    }

@app.post("/city/{user_id}/place")
async def place_building(user_id: str, request: PlaceRequest):
    building_type = request.building_type
    x = request.x
    y = request.y

    if building_type not in BUILDING_CONFIG:
        raise HTTPException(status_code=400, detail="Neznámý typ budovy")

    current_time = time.time()
    buildings_raw = await redis_client.get(f"city:{user_id}:buildings")
    resources_raw = await redis_client.hgetall(f"player:{user_id}")

    if not buildings_raw or not resources_raw:
        raise HTTPException(status_code=404, detail="Hráč neexistuje")

    buildings = json.loads(buildings_raw)
    resources = {k: float(v) for k, v in resources_raw.items() if k in ["gold", "wood"]}

    # Kontrola obsazení pozice
    for b_data in buildings.values():
        if b_data.get("x") == x and b_data.get("y") == y:
            raise HTTPException(status_code=400, detail="Pozice je již obsazená")

    config = BUILDING_CONFIG[building_type]
    build_cost_gold = config["upgrade_cost_gold"][1]  # cena za level 1→2 použijeme jako cenu za novou

    if resources["gold"] < build_cost_gold:
        raise HTTPException(status_code=400, detail="Nedostatek gold na postavení")

    # Vytvoř unikátní ID
    new_id = f"{building_type}_{len(buildings)}"

    buildings[new_id] = {
        "level": 1,
        "upgrade_start": None,
        "upgrade_end": None,
        "x": x,
        "y": y,
        "type": building_type
    }

    resources["gold"] -= build_cost_gold

    await redis_client.hset(f"player:{user_id}", "gold", resources["gold"])
    await redis_client.set(f"city:{user_id}:buildings", json.dumps(buildings))

    return {
        "message": f"Budova {building_type} postavena na ({x},{y})",
        "building_id": new_id,
        "cost_gold": build_cost_gold
    }
